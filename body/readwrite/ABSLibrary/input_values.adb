with Interfaces.C; use Interfaces.C;

package body Input_Values is

-- -------------------------------------------------------------
-- Every package shall contain the following strings that are       
-- generated by svn automatically (after initial setup by hand)                   
--
   svn_author  : constant String := "$Author: lf3eelma $";
   svn_revision: constant String := "$Revision: 2085 $";
   svn_date    : constant String := "$Date: 2020-07-01 13:42:13 +0200 (Mi, 01 Jul 2020) $";
-- 
-- To enable the mechanism:                                 
-- 1) Run
-- svn propset svn:keywords "Author Rev Date" <name of file> 
-- 2) Copy-Paste to the file the strings
-- svn_author  : constant String := "$Author: lf3eelma $";
-- svn_revision: constant String := "$Revision: 2085 $";
-- svn_date    : constant String := "$Date: 2020-07-01 13:42:13 +0200 (Mi, 01 Jul 2020) $";
-- 
-- If a package consists of a body and a specification file
-- then include the strings in the body file. 
-- -------------------------------------------------------------


-- --------------------------------
-- Install ------------------------
-- --------------------------------

function Install(P : Problem_T) return Input_Grid_T is
 subdivision : InputGrid.Vector_of_Coordinate_Index (P.Initial_Input_Space_Subdivision'Range);
 Grid : Input_Grid_T;
 a : Input_T (P.umin'Range);
 b : Input_T (P.umin'Range);
 c : InputGrid.Vector_of_Coordinate_Index (P.Initial_Input_Space_Subdivision'Range);
 use InputGrid;
begin
  for i in P.Initial_Input_Space_Subdivision'Range loop
   subdivision(i):=InputGrid.Unsigned_Coordinate_Index_Type(P.Initial_Input_Space_Subdivision(i));
   c(i) := subdivision(i) + 1 ;
  end loop;
  for i in P.umin'Range loop
    if P.umin(i) = P.umax(i) then
     null;
    end if;
   a(i) := P.umin(i) - (P.umax(i) - P.umin(i))/Float_T(subdivision(i))/2.0;
   b(i) := P.umax(i) + (P.umax(i) - P.umin(i))/Float_T(subdivision(i))/2.0;
  end loop;
 InputGrid.init(grid        => InputGrid.Grid_Record(Grid),
                subdivision => c,
                xmin        => a,
                xmax        => b);
 return Grid;
end Install;

function Install(P : Problem_T_Access) return Input_Grid_T is
begin
 return Install(P.all);
end Install;

-- --------------------------------
-- Get_First_Index ----------------
-- --------------------------------

function Get_First_Index(Inputs : in Input_Grid_T) return Input_Index_T
is
begin
 return 0;
end Get_First_Index;

-- --------------------------------
-- Get_Last_Index -----------------
-- --------------------------------

function Get_Last_Index(Inputs : in Input_Grid_T) return Input_Index_T
is
begin
 return InputGrid.get_last_used_index(InputGrid.Grid_Record(Inputs));
end Get_Last_Index;

-- --------------------------------
-- Get_Input_Value ----------------
-- --------------------------------

procedure Get_Input_Value(u         : out Input_T; 
                          idx       : in Input_Index_T; 
                          InputData : in Input_Grid_T)
is 
begin 
 InputGrid.get_gridpoint(u,idx,InputGrid.Grid_Record(InputData));
end Get_Input_Value;


procedure Get_Input_Coord (coord_u        : out Input_Coord_T; 
                          idx             : in Input_Index_T; 
                          InputData       : in Input_Grid_T) is

begin

InputGrid.get_coordinate(coord_u,idx,InputGrid.Grid_Record(InputData));
end Get_Input_Coord;


    procedure Get_Input_Index (coord_u        : in Input_Coord_T; 
                          idx             : out Input_Index_T; 
                          InputData       : in Input_Grid_T) is
                          
                          begin
                          
                          
idx:=InputGrid.get_index(coord_u,InputGrid.Grid_Record(InputData));

                          end Get_Input_Index;

end Input_Values;
