with Established_Types; use Established_Types;
with dynamics_specification_parameters; use dynamics_specification_parameters;
with Ada.Unchecked_Deallocation;

with Interfaces.C;

package body Problem_Loading is

-- -------------------------------------------------------------
-- Every package shall contain the following strings that are       
-- generated by svn automatically (after initial setup by hand)                   
--
   svn_author  : constant String := "$Author: lf1balwe $";
   svn_revision: constant String := "$Revision: 1149 $";
   svn_date    : constant String := "$Date: 2017-05-30 18:15:52 +0200 (Di, 30 Mai 2017) $";
-- 
-- To enable the mechanism:                                 
-- 1) Run
-- svn propset svn:keywords "Author Rev Date" <name of file> 
-- 2) Copy-Paste to the file the strings
-- svn_author  : constant String := "$Author: lf1balwe $";
-- svn_revision: constant String := "$Revision: 1149 $";
-- svn_date    : constant String := "$Date: 2017-05-30 18:15:52 +0200 (Di, 30 Mai 2017) $";
-- 
-- If a package consists of a body and a specification file
-- then include the strings in the body file. 
-- -------------------------------------------------------------


-- --------------------------------
-- Install ------------------------
-- --------------------------------

function Install return Problem_T
is

   State_Space_Dimension  : constant Component_Index_T := Get_State_Space_Dimension;
   Input_Space_Dimension  : constant Component_Index_T := Get_Input_Space_Dimension;

   Periods               : constant List_of_Component_Index_T (1 .. Get_Num_Of_Coord_With_Periods)    := Get_Coord_With_Periods;
   No_Periods            : constant List_of_Component_Index_T (1 .. Get_Num_Of_Coord_Without_Periods) := Get_Coord_Without_Periods;

   Uncertainties        : constant Bounds_of_Dynamic_Uncertainties_T (1 .. State_Space_Dimension) := Get_Bounds_of_Dynamic_Uncertainties;
   Measurement_Errors   : constant Bounds_of_Measurement_Errors_T    (1 .. State_Space_Dimension) := Get_Bounds_of_Measurement_Errors;

   Sampling_Time         : constant Time_T := Get_Sampling_Time;

   Initial_Set           : Compact_Hyperinterval_T_Array (1 .. Get_Num_Of_Initial_Set) := Get_Initial_Set;
   Target_Set            : Compact_Hyperinterval_T_Array (1 .. Get_Num_Of_Target_Set)  := Get_Target_Set;
   Obstacle_Set          : Compact_Hyperinterval_T_Array (1 .. Get_Num_Of_Obstacle_Set):= Get_Obstacle_Set;

   Operating_Range       : Compact_Hyperinterval_T_Array (1 .. 1) := Get_Operating_Range;
   Input_Space           : Compact_Hyperinterval_T_Array (1 .. 1) := Get_Input_Space;
   State_Space_Subdivision   : constant State_Space_Subdivision_T (1 .. State_Space_Dimension) := Get_Initial_State_Space_Subdivision;
   Input_Space_Subdivision   : constant Input_Space_Subdivision_T (1 .. Input_Space_Dimension) := Get_Initial_Input_Space_Subdivision;

   problem              : Problem_T;
 
   use Interfaces.C;
begin

   -- Read and write the data that do need further processing
   problem.State_Space_Dimension    := State_Space_Dimension;
   problem.Input_Space_Dimension    := Input_Space_Dimension;
   problem.xmin                   := new State_T (1 .. State_Space_Dimension);
   problem.xmax                   := new State_T (1 .. State_Space_Dimension);
   for i in problem.xmin'Range loop
   problem.xmin(i)                := Operating_Range(1)(Lower)(i);
   problem.xmax(i)                := Operating_Range(1)(Upper)(i);
   end loop;
   problem.umin                   := new Input_T (1 .. Input_Space_Dimension);
   problem.umax                   := new Input_T (1 .. Input_Space_Dimension);
   for i in problem.umin'Range loop
   problem.umin(i)                := Input_Space(1)(Lower)(i);
   problem.umax(i)                := Input_Space(1)(Upper)(i);
   end loop;
   
   problem.Initial_State_Space_Subdivision      := new State_Space_Subdivision_T (1 .. State_Space_Dimension);
   problem.Initial_State_Space_Subdivision.all  := State_Space_Subdivision;
   problem.Initial_Input_Space_Subdivision      := new Input_Space_Subdivision_T (1 .. Input_Space_Dimension);
   problem.Initial_Input_Space_Subdivision.all  := Input_Space_Subdivision;

   problem.List_of_periodic_components        := new List_of_Component_Index_T (Periods'Range);
   problem.List_of_periodic_components.all    := Periods;
   problem.List_of_nonperiodic_components     := new List_of_Component_Index_T (No_Periods'Range);
   problem.List_of_nonperiodic_components.all := No_Periods;

   problem.Bounds_of_Dynamic_Uncertainties     := new Bounds_of_Dynamic_Uncertainties_T (Uncertainties'Range);
   problem.Bounds_of_Dynamic_Uncertainties.all := Uncertainties;
   problem.Bounds_of_Measurement_Errors        := new Bounds_of_Measurement_Errors_T (Measurement_Errors'Range);
   problem.Bounds_of_Measurement_Errors.all    := Measurement_Errors;

   problem.Sampling_Time          := Sampling_Time;
   problem.Initial_State_Set      := new Compact_Hyperinterval_T_Array (Initial_Set'Range);
   problem.Initial_State_Set.all  := Initial_Set;
   problem.Target_State_Set             := new Compact_Hyperinterval_T_Array (Target_Set'Range);
   problem.Target_State_Set.all         := Target_Set;
   problem.Obstacle_State_Set           := new Compact_Hyperinterval_T_Array (Obstacle_Set'Range);
   problem.Obstacle_State_Set.all       := Obstacle_Set;

   problem.General_Solution_Formula    := Integration'Access;
   problem.Growth_Bound_Formula   := Integration_for_growth_bound'Access;

   problem.Rounded_Initial_State_Radius := new State_Radius_T (problem.xmax'Range);
   problem.Rounded_Initial_State_Radius.all := Get_Rounded_Initial_State_Radius;
   problem.Bounds_of_Lipschitz_Matrices := new Vector_Float_T (1 .. State_Space_Dimension**2);
   problem.Bounds_of_Lipschitz_Matrices.all := Get_Bounds_of_Lipschitz_Matrices;  

   problem.Bounds_of_Input_Value_Rounding_Error := new Bounds_of_Numerical_Errors_Input_T (problem.umin'Range);
   problem.Bounds_of_Input_Value_Rounding_Error.all := Get_Bounds_of_Input_Value_Rounding_Error;
   problem.Bounds_of_Approximation_Error_of_General_Solution := new Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Approximation_Error_of_General_Solution.all := Get_Bounds_of_Approximation_Error_of_General_Solution;
   problem.Bounds_of_Rounding_Error_of_General_Solution := new Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Rounding_Error_of_General_Solution.all := Get_Bounds_of_Rounding_Error_of_General_Solution;
   problem.Bounds_of_Approximation_Error_of_Growth_Bound := new Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Approximation_Error_of_Growth_Bound.all := Get_Bounds_of_Approximation_Error_of_Growth_Bound;
   problem.Bounds_of_Rounding_Error_of_Growth_Bound := new  Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Rounding_Error_of_Growth_Bound.all := Get_Bounds_of_Rounding_Error_of_Growth_Bound;
   problem.Bounds_of_Summation_Error_Growth_Bound := new Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Summation_Error_Growth_Bound.all := Get_Bounds_of_Summation_Error_Growth_Bound;
   problem.Bounds_of_Summation_Error_General_Solution := new Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Summation_Error_General_Solution.all := Get_Bounds_of_Summation_Error_General_Solution;
   problem.Bounds_of_Overapproximation_Rounding_Error := new Bounds_of_Numerical_Errors_State_T (problem.xmin'Range);
   problem.Bounds_of_Overapproximation_Rounding_Error.all := Get_Bounds_of_Overapproximation_Rounding_Error;
   return problem;
end install;

end Problem_Loading;
