with Interfaces; use Interfaces;
with Interfaces.C; use Interfaces.C;
with Input_values; use Input_values;
with Ada.Unchecked_Deallocation;
with Ada.Text_IO; use Ada.Text_IO;

package body Bounds_Approximation_Error is

-- -------------------------------------------------------------
-- Every package shall contain the following strings that are       
-- generated by svn automatically (after initial setup by hand)                   
--
   svn_author  : constant String := "$Author: lf1agure $";
   svn_revision: constant String := "$Revision: 1125 $";
   svn_date    : constant String := "$Date: 2017-05-12 10:02:16 +0200 (Fr, 12. Mai 2017) $";
-- 
-- To enable the mechanism:                                 
-- 1) Run
-- svn propset svn:keywords "Author Rev Date" <name of file> 
-- 2) Copy-Paste to the file the strings
-- svn_author  : constant String := "$Author: lf1agure $";
-- svn_revision: constant String := "$Revision: 1125 $";
-- svn_date    : constant String := "$Date: 2017-05-12 10:02:16 +0200 (Fr, 12. Mai 2017) $";
-- 
-- If a package consists of a body and a specification file
-- then include the strings in the body file. 
-- -------------------------------------------------------------

function  Compute( apriori_enclosure    : in Compact_Hyperinterval_T; 
                      sampling_time     : in Time_T  ; 
                  input_value_lower     : in Input_T ; 
                  input_value_upper     : in Input_T ;
                  subdivisions_in_state : in Positive_Integer_T ;
                  subdivisions_in_input : in Positive_Integer_T  ) return Bounds_of_Numerical_Errors_State_T
is
  n : constant Component_Index_T := apriori_enclosure(Lower)'Length;
  m : constant Component_Index_T := input_value_lower'Length;
  type Vector_double_T         is array (1 .. n) of double;
  type Input_Hyperinterval_double_T is array (1 .. 2*m) of double;
  type State_Hyperinterval_double_T is array (1 .. 2*n) of double;
  BoundDouble       : Vector_double_T;
  AprioriEnclDouble : State_Hyperinterval_double_T;
  UDouble           : Input_Hyperinterval_double_T;
  Status            : unsigned;
  retval            : Bounds_of_Numerical_Errors_State_T ( 1 .. n );
 function bounds_of_approximation_error(bound      : out Vector_double_T ; 
                                        ap_enc     : in State_Hyperinterval_double_T;
                                        u          : in Input_Hyperinterval_double_T;
                                        tau        : in double ;
                                        subd_state : in unsigned ;
                                        subd_input : in unsigned ;
                                        n          : in unsigned ;
                                        m          : in unsigned ) return unsigned;
 pragma Import (C,bounds_of_approximation_error,"bounds_of_approximation_error");
begin
 for i in Component_Index_T range 1 .. n loop
  AprioriEnclDouble(i)     := double(apriori_enclosure(Lower)(i));
  AprioriEnclDouble(i + n) := double(apriori_enclosure(Upper)(i));
  BoundDouble(i) := double(0.0);
 end loop;
 for i in 1 .. m loop
  UDouble(i)   := double(input_value_lower(i));
  UDouble(i+m) := double(input_value_upper(i));
 end loop;
 Status := bounds_of_approximation_error(BoundDouble,AprioriEnclDouble,UDouble,double(Sampling_Time),unsigned(3),unsigned(1),unsigned(n),unsigned(m));
 if Status /= 0 then raise Storage_Error; end if;
 for i in 1 .. n loop
  retval(i) := BoundDouble(i);
 end loop;
 return retval;
end Compute;

procedure Compute(P : in out Problem_T) is
 n : constant Component_Index_T := P.State_Space_Dimension;
 m : constant Component_Index_T := P.Input_Space_Dimension;
 u_min : Input_T ( 1 .. m );
 u_max : Input_T ( 1 .. m );
 tmp : Bounds_of_Numerical_Errors_State_T ( 1 .. n );
begin
 for i in 1 .. m loop
  u_min(i)   := P.umin(i) - P.Bounds_of_Input_Value_Rounding_Error(i);
  u_max(i) := P.umax(i) + P.Bounds_of_Input_Value_Rounding_Error(i);
 end loop;
 tmp := Compute(P.Apriori_Enclosure.all,P.Sampling_Time,u_min,u_max,3,1);
 for i in 1 .. n loop
 P.Bounds_of_Approximation_Error_of_General_Solution(i) := established_types.Float_T'Min(P.Bounds_of_Approximation_Error_of_General_Solution(i),tmp(i));
  end loop;
end Compute;

--procedure Compute(P : in out Problem_T) is
--  n : constant Component_Index_T := P.State_Space_Dimension;
--  m : constant Component_Index_T := P.Input_Space_Dimension;
--  type Vector_double_T         is array (1 .. n) of double;
--  type Input_Hyperinterval_double_T is array (1 .. 2*m) of double;
--  type State_Hyperinterval_double_T is array (1 .. 2*n) of double;
--  BoundDouble       : Vector_double_T;
--  AprioriEnclDouble : State_Hyperinterval_double_T;
--  UDouble           : Input_Hyperinterval_double_T;
--  Status            : unsigned;
-- function bounds_of_approximation_error(bound             : out Vector_double_T ; 
--                                        apriori_enclosure : in State_Hyperinterval_double_T;
--                                        u                 : in Input_Hyperinterval_double_T;
--                                        tau               : in double ;
--                                        n                 : in unsigned ;
--                                        m                 : in unsigned ) return unsigned;
-- pragma Import (C,bounds_of_approximation_error,"bounds_of_approximation_error");
-- begin
-- for i in Component_Index_T range 1 .. n loop
-- AprioriEnclDouble(i)     := double(P.Apriori_Enclosure(Lower)(i));
--  AprioriEnclDouble(i + n) := double(P.Apriori_Enclosure(Upper)(i));
--  BoundDouble(i) := double(P.Bounds_of_Approximation_Error_of_General_Solution(i));
-- end loop;
-- for i in 1 .. m loop
--  UDouble(i)   := double(P.umin(i) - P.Bounds_of_Input_Value_Rounding_Error(i));
--  UDouble(i+m) := double(P.umax(i) + P.Bounds_of_Input_Value_Rounding_Error(i));
-- end loop;
-- 
-- Status := bounds_of_approximation_error(BoundDouble,AprioriEnclDouble,UDouble,double(P.Sampling_Time),unsigned(n),unsigned(m));
-- if Status /= 0 then raise Constraint_Error; end if;
-- for i in 1 .. n loop
--  P.Bounds_of_Approximation_Error_of_General_Solution(i) := BoundDouble(i);
-- end loop;
-- end Compute;

   
     procedure Set_Errors_to_Zero(P : in out Problem_T) is
     
   n : constant Component_Index_T := P.State_Space_Dimension;
     m : constant Component_Index_T := P.Input_Space_Dimension;     
      
      
      
   begin 
      

      

      for i in 1..m loop
         P.Bounds_of_Input_Value_Rounding_Error(i):=0.0;
      
      end loop;
      
      for i in 1..n loop

         P.Bounds_of_Approximation_Error_of_General_Solution(i):=0.0;

         P.Bounds_of_Rounding_Error_of_General_Solution(i):=0.0;
    
         P.Bounds_of_Approximation_Error_of_Growth_Bound(i):=0.0;
         
         P.Bounds_of_Rounding_Error_of_Growth_Bound(i):=0.0;
       
         P.Bounds_of_Summation_Error_Growth_Bound(i):=0.0;
           
         P.Bounds_of_Summation_Error_General_Solution(i):=0.0;
   
         P.Bounds_of_Overapproximation_Rounding_Error(i):=0.0;
      
       --  P.Bounds_of_Overapproximation_Radius(i):=0.0;
         
      end loop;
      
      
      
      
      end Set_Errors_to_Zero;

end Bounds_Approximation_Error;
