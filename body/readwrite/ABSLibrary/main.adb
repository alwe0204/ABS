with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO;
with Interfaces.C; use Interfaces.C;

with abcs_text_io; use abcs_text_io;

with Established_Types; use Established_Types;
with Input_Values; use Input_Values;

with problem_loading;

with cell_cover; use cell_cover;

with apriori_enclosure;

with Bounds_Approximation_Error;

with Growth_Bound;

with abstraction_i14sym; use abstraction_i14sym;
with abstraction_i14sym.computation;

with dijkstra_algorithm_i13absoc;

with output_results;
with Ada.Calendar; use Ada.Calendar;

with Ada.Strings.Fixed;
use Ada.Strings.Fixed;
with Ada.Strings.Unbounded;
use Ada.Strings.Unbounded;

function Main return Integer is

-- -------------------------------------------------------------
-- Every package shall contain the following strings that are       
-- generated by svn automatically (after initial setup by hand)                   
--
   svn_author  : constant String := "$Author: lf3eelma $";
   svn_revision: constant String := "$Revision: 2459 $";
   svn_date    : constant String := "$Date: 2021-11-16 08:12:42 +0100 (Di, 16 Nov 2021) $";
-- 
-- To enable the mechanism:                                 
-- 1) Run
-- svn propset svn:keywords "Author Rev Date" <name of file> 
-- 2) Copy-Paste to the file the strings
-- svn_author  : constant String := "$Author: lf3eelma $";
-- svn_revision: constant String := "$Revision: 2459 $";
-- svn_date    : constant String := "$Date: 2021-11-16 08:12:42 +0100 (Di, 16 Nov 2021) $";
-- 
-- If a package consists of a body and a specification file
-- then include the strings in the body file. 
-- -------------------------------------------------------------

   version        : constant String := "10-2021";
   display_length : constant := 42;
   P                               : Problem_T := problem_loading.install;
   apriori_enclosure_of_target_set : Compact_Hyperinterval_T ;
   
   -- Load the control problem and the other parameters
   GB                : Growth_Bound.Growth_Bound_Values_T_Access;
   GB_b              : Growth_Bound.Growth_Bound_Values_T_Access;
   GB_b_w            : Growth_Bound.Growth_Bound_Values_T_Access;
   -- Instantiate growth bound and compute;
   Abstraction           : Abstraction_T_Access; 
  -- Abstraction_OTF           : abstraction_i14sym.Abstraction_T(Solution=>Solution_Method'(on_the_fly));
   -- Data structure for the abstraction
   AbstractSpecification : abstraction_i14sym.Abstract_Specification_T;
   -- Data structure for the abstract specification 
 

   center                : State_T (P.xmin'Range);
   beta                  : State_Radius_T (P.xmin'Range);
   u                     : Input_T (P.umin'Range) := (others => 0.0);
   -- Temporary variables
   cover                 : Cell_Cover_T ;
   -- Instantiate the input grid
   InputData             : Input_Grid_T    := Input_Values.Install(P);
   procedure Lipschitz_Method (successors : in out Dynamic_Cell_Container; 
                               cell       : in Cell_Index_T; 
                               v          : in Input_Index_T) is
    use Interfaces.C;
   begin
    Get_Center_Of_Cell(center,cell,cover);
    Get_Input_Value(u,v,InputData);
    P.General_Solution_Formula(center,P.Sampling_Time,center,u);
    Growth_Bound.Get_Growth_Bound ( beta, GB, Cell, v );    
    for i in beta'Range loop
     beta(i) := (
                 P.Bounds_of_Approximation_Error_of_General_Solution(i) + 
                 P.Bounds_of_Rounding_Error_of_General_Solution(i) + 
                 beta(i)
                 + 
                 P.Bounds_of_Summation_Error_General_Solution(i)) +
                 P.Bounds_of_Measurement_Errors(i)
                 ;
    end loop;
    CellGrid.findintersectingcells(cells   => successors,
                                   center  => center,
                                   rad     => beta,
                                   grid    => CellGrid.Grid_on_Manifold_Record(cover));
   end Lipschitz_Method;
   
   
   
 procedure Lipschitz_Method_backward (successors : in out Dynamic_Cell_Container; 
                               cell       : in Cell_Index_T; 
                               v          : in Input_Index_T) is
    use Interfaces.C;
   begin
    Get_Center_Of_Cell(center,cell,cover);
    Get_Input_Value(u,v,InputData);
    P.General_Solution_Formula(center,-P.Sampling_Time,center,u);
    Growth_Bound.Get_Growth_Bound ( beta, GB_b, Cell, v );    
    for i in beta'Range loop
     beta(i) := (
                 P.Bounds_of_Approximation_Error_of_General_Solution(i) + 
                 P.Bounds_of_Rounding_Error_of_General_Solution(i) + 
                 beta(i)
                 + 
                 P.Bounds_of_Summation_Error_General_Solution(i)) +
                 P.Bounds_of_Measurement_Errors(i)
                 ;
    end loop;
    CellGrid.findintersectingcells(cells   => successors,
                                   center  => center,
                                   rad     => beta,
                                   grid    => CellGrid.Grid_on_Manifold_Record(cover));
   end Lipschitz_Method_backward;
   

    procedure Lipschitz_Method_backward_with_disturbance (successors : in out Dynamic_Cell_Container; 
                               cell       : in Cell_Index_T; 
                               v          : in Input_Index_T) is
    use Interfaces.C;
   begin
    Get_Center_Of_Cell(center,cell,cover);
    Get_Input_Value(u,v,InputData);
    P.General_Solution_Formula(center,-P.Sampling_Time,center,u);
    Growth_Bound.Get_Growth_Bound ( beta, GB_b_w, Cell, v );    
    for i in beta'Range loop
     beta(i) := (
                 P.Bounds_of_Approximation_Error_of_General_Solution(i) + 
                 P.Bounds_of_Rounding_Error_of_General_Solution(i) + 
                 beta(i)
                 + 
                 P.Bounds_of_Summation_Error_General_Solution(i)) +
                 P.Bounds_of_Measurement_Errors(i)
                 ;
    end loop;
    CellGrid.findintersectingcells(cells   => successors,
                                   center  => center,
                                   rad     => beta,
                                   grid    => CellGrid.Grid_on_Manifold_Record(cover));
                            
                            
                                   
   end Lipschitz_Method_backward_with_disturbance;
   
   
   
   
   
   
   
   
   container  : Dynamic_Cell_Container;                                   

   function Abstract_Reachable_Set_Traversal (
                                              cell       : in  Cell_Index_T; 
                                              v          : in Input_Index_T;                                            
                                              successor  : out Cell_Index_T;
                                              overapproximation : out Abstract_Reachable_Set_Geometry_T;
                                              Test_procedure_not_in_E:  access function (cell: in Cell_Index_T; successor : in Cell_Index_T) return Boolean;
                                              Test_procedure_obstacle_suboptimal_or_self_loop:  access function (cell: in Cell_Index_T;successor : in Cell_Index_T) return Boolean
                                             ) return Boolean is
      use Interfaces.C;
      traversal_complete:Boolean;

    begin


    
    Get_Center_Of_Cell(center,cell,cover);
    Get_Input_Value(u,v,InputData);
    
    
    P.General_Solution_Formula(center,P.Sampling_Time,center,u);
    Growth_Bound.Get_Growth_Bound ( beta, GB, Cell, v );    
    for i in beta'Range loop
     beta(i) := (
                 P.Bounds_of_Approximation_Error_of_General_Solution(i) + 
                 P.Bounds_of_Rounding_Error_of_General_Solution(i) + 
                 beta(i)
                 + 
                 P.Bounds_of_Summation_Error_General_Solution(i)) +
                 P.Bounds_of_Measurement_Errors(i)
                 ;
      end loop;
      
      Empty_container(container => container);
      
      traversal_complete:=CellGrid.traverse_overapproximation(
                                                              cell=>cell,
                                                              center => center,
                                                              rad => beta,
                                                              grid => CellGrid.Grid_on_Manifold_Record(cover),
                                                              successors => container ,
                                                              Boolean_Test_1 => Test_procedure_not_in_E,
                                                              Boolean_Test_2 => Test_procedure_obstacle_suboptimal_or_self_loop);
 
   
      if traversal_complete then 
     
         successor:=container.Dynamic_Container(0);
         overapproximation.lower:= container.Dynamic_Container(1);
         overapproximation.upper:= container.Dynamic_Container(2);  
         
         
         return True;
   
      else 
         
         successor:=container.Dynamic_Container(0);
         overapproximation.lower:= container.Dynamic_Container(1);
         overapproximation.upper:= container.Dynamic_Container(2);
         return false;
      end if;
      
      
   
   end Abstract_Reachable_Set_Traversal;
   
   

                                      

   
   
   
   
   function Continue_Abstract_Reachable_Set_Traversal (
                                                       cell                : in Cell_Index_T;
                                                       current_successor   : in  Cell_Index_T;
                                                       next_successor      : out Cell_Index_T;          
                                                       overapproximation   : in Abstract_Reachable_Set_Geometry_T;
                                                       Test_procedure_not_in_E
                                                                       :access function (cell: in Cell_Index_T;successor : in Cell_Index_T) return Boolean;
                                                       Test_procedure_obstacle_suboptimal_or_self_loop
                                                                       :access function (cell: in Cell_Index_T;successor : in Cell_Index_T) return Boolean
                                                      ) return Boolean is
    
      traversal_complete:Boolean;
   begin
   
      Empty_container(container => container);
      
      traversal_complete:=CellGrid.continue_traverse_overapproximation(
                                                                       cell             => cell,
                                                                       grid             => CellGrid.Grid_on_Manifold_Record(cover),
                                                                       successors       => container,
                                                                       lower_index      => overapproximation.Lower,
                                                                       upper_index      => overapproximation.Upper,
                                                                       start_index      => current_successor,
                                                                       Boolean_Test_1   => Test_procedure_not_in_E,
                                                                       Boolean_Test_2   => Test_procedure_obstacle_suboptimal_or_self_loop
                                                                      );
   
      if traversal_complete then 
         
         return True;
   
      else 
         
         next_successor:=container.Dynamic_Container(0);
         return false;
         
      end if;
      
      
   end Continue_Abstract_Reachable_Set_Traversal;
   
   
   
   function Belongs_to_Abstract_Reachable_Set (
                                               cell              : in Cell_Index_T;         
                                               overapproximation : in Abstract_Reachable_Set_Geometry_T                                                  
                                              ) return Boolean is
    
      belongs:Boolean;
   begin
   

      
      belongs:=CellGrid.belongs_to_overapproximation(cell        => cell,
                                                     grid        => CellGrid.Grid_on_Manifold_Record(cover),
                                                     lower_index => overapproximation.Lower,
                                                     upper_index => overapproximation.Upper);
   

      
      return belongs;
   end Belongs_to_Abstract_Reachable_Set;
   
   
   
   
   
   
   
   
   -- Definition of the overapproximation method
  
   procedure Abstraction_Compute is new abstraction_i14sym.computation.compute(get_successors => Lipschitz_Method);
   -- Definition of the method to compute abstractions
   
   package Controller_Synthesis is new dijkstra_algorithm_i13absoc(Transition_Weight_T => Float_T); 
   -- Definition of the controller synthesis method
   procedure Solve_Control_Problem is new  Controller_Synthesis.Compute(backward_estimator                        => Lipschitz_Method_backward,
                                                                            Backward_Reachable_Set                    => Lipschitz_Method_backward_with_disturbance,
                                                                            Belongs_to_Abstract_Reachable_Set         => Belongs_to_Abstract_Reachable_Set,
                                                                            Abstract_Reachable_Set_Traversal          => Abstract_Reachable_Set_Traversal,
                                                                            Continue_Abstract_Reachable_Set_Traversal => Continue_Abstract_Reachable_Set_Traversal);
     
     
     
                                  
   Solution : Controller_Synthesis.Abstract_OCP_Solution_Type;
   -- Data structure for the solution of the control problem
   Start_Time        :Time;
   End_Time          :Time; 
   User_Choice       :Integer;
   Valid_user_Input  :Boolean:=False;
   Expand_enclosure  :Boolean:=False;
   

 --  a:C.int;
   File : File_Type;
   Status_file:Boolean:=True;
   Found_mem_info_in_system_file:Boolean:=False;
   String_w_mem_info: Ada.Strings.Unbounded.Unbounded_String;   
   Compute_enclosure_only_status:Boolean:=False;
   
begin
   Put_Line("----------------------------------------------------");
   Put_Line("------- Abstraction-based Controller Synthesis------");
   Put_Line("--------For Reach-Avoid && Invariance Problems------");
   Put_Line("---------------------- " & version & " ---------------------");
   Put_Line("----------------------------------------------------");
   New_Line;
   Put_Line("Choose problem and solution  type");
   Put_Line("(0) - On-the-fly solution to the reach avoid problem") ; 
   Put_Line("(1) - On-the-fly solution to the invariance  problem") ; 
   Put_Line("(2) - Standard   solution to the reach avoid problem") ; 
   Put_Line("(3) - Standard   solution to the invariance  problem") ; 
 --  Put_Line("(4) - Compute apriori enclosure and quit") ; 
   while Valid_user_Input/=True loop
     Ada.Integer_Text_IO.Get(User_Choice);
     
        case User_Choice is
          when 0 =>
          
             Initialize_Abstraction(Abstraction    => Abstraction,
                          Representation => Specification_SynthesisMethod_AbstractionRepresentation'(ReachAvoid_OnTheFlyDijkstra_SparseMatrix));
   
           
         
           Valid_user_Input:=True;
       
          when 1 =>
          
          
             Initialize_Abstraction(Abstraction    => Abstraction,
                          Representation => Specification_SynthesisMethod_AbstractionRepresentation'(Invariance_OnTheFlyMethod_SparseMatrix));
   
          
          
           Valid_user_Input:=True;
          
           when 2 =>
              

             Initialize_Abstraction(Abstraction    => Abstraction,
                          Representation => Specification_SynthesisMethod_AbstractionRepresentation'(ReachAvoid_StandardDijkstra_SparseMatrix));
   
          
          
           Valid_user_Input:=True;
          
              
           when 3 =>

             Initialize_Abstraction(Abstraction    => Abstraction,
                          Representation => Specification_SynthesisMethod_AbstractionRepresentation'(Invariance_StandardMethod_SparseMatrix));
   
           Valid_user_Input:=True;
          
           
         --   when 4 =>
              
        --      Compute_enclosure_only_status:=True;
        --       Valid_user_Input:=True;
           
         when others =>

              Put_Line("Incorrect input, try again");
        
        end case;
        
     end loop;
--     
--     
--     
  --  return 0;
   


   New_Line;
   Put_Line("- Apriori Enclosure: "); 
   Start_Time:= Clock;
   apriori_enclosure.compute(P);
   End_Time:= Clock;
   Put_Line("  Done." &" Time: "&Float(End_Time-Start_Time)'img);
   
   if User_Choice=1 then
   Put_Line("- Checking if State Domain contains apriori enclosure of the Target Set "); 
   Start_Time:= Clock;
   for i in End_Point_T loop
      apriori_enclosure_of_target_set(i) := new Vector_Float_T (P.xmin'Range);      
   end loop; 
   
   for i in    apriori_enclosure_of_target_set(Lower)'range loop
     apriori_enclosure_of_target_set(Lower)(i) := P.xmin(i); 
     apriori_enclosure_of_target_set(Upper)(i) := P.xmax(i);      
   end loop; 

   for i in P.Target_State_Set'Range loop
   
   declare
   P_tmp       : Problem_T := problem_loading.install;
   begin
   for  j in P_tmp.xmin'Range loop
   P_tmp.xmin(j):=P_tmp.Target_State_Set(i)(Lower)(j);
   P_tmp.xmax(j):=P_tmp.Target_State_Set(i)(Upper)(j); 
   end loop;
   
   apriori_enclosure.compute(P_tmp);
   
   for j in    apriori_enclosure_of_target_set(Lower)'range loop
   
   if apriori_enclosure_of_target_set(Lower)(j) > P_tmp.Apriori_Enclosure(Lower)(j) then
   apriori_enclosure_of_target_set(Lower)(j) := P_tmp.Apriori_Enclosure(Lower)(j);
   Expand_enclosure  :=True;
   end if; 
   
   if apriori_enclosure_of_target_set(Upper)(j) < P_tmp.Apriori_Enclosure(Upper)(j) then
   apriori_enclosure_of_target_set(Upper)(j) := P_tmp.Apriori_Enclosure(Upper)(j);
   Expand_enclosure  :=True;
   end if; 
   
   end loop;
   
   end;
   
   
   end loop;
   End_Time:= Clock;

   if Expand_enclosure then
   Put_Line("  False.");
   Put_Line("  Done." &" Time: "&Float(End_Time-Start_Time)'img);
   
   Put_Line("  Error: Operating Range in the input file does NOT contain apriori enclosure of the Target Set.");
   Put_Line("         Not Possible to apply the chosen synthesis algorithm.");
   Put_Line("  Update the input file with the following Operating Range to apply the chosen synthesis algorithm:");
   Put     ("  OperatingRange:(");
   
   for i in    apriori_enclosure_of_target_set(Lower)'range loop
   Put("[");
   Put(apriori_enclosure_of_target_set(Lower)(i)'img);
   Put(",");
   Put(apriori_enclosure_of_target_set(Upper)(i)'img);
   Put("]"); 
   if i/=apriori_enclosure_of_target_set(Lower)'Last then
    Put(","); 
   end if;
   end loop;
   
   Put     (" );");
   New_Line;
   return 1;
   end if;
   
   Put_Line("  True.");
   Put_Line("  Done." &" Time: "&Float(End_Time-Start_Time)'img);
   end if;
   
 --  if Get_Abstraction_Data_Structure(Abstraction.all) = Specification_SynthesisMethod_AbstractionRepresentation'(Invariance_OnTheFlyMethod_SparseMatrix) then
 --    Put_Line("- Expanding State Domain to Apriori Enclosure: "); 
 --     Apriori_Enclosure.Expand_State_Domain(P);
      
 --     for i in P.xmin'range loop
 --     Put_Line("xmin: "&P.xmin(i)'img);
 --     Put_Line("xmax: "&P.xmax(i)'img);
 --     end loop;
      
 --     Put_Line("- Computing new Apriori Enclosure: ");
 --     Start_Time:= Clock;
 --     apriori_enclosure.compute(P);
 --     End_Time:= Clock;
  --   Put_Line("  Done." &" Time: "&Float(End_Time-Start_Time)'img);

  
      
--   end if;


        cover                 := cell_cover.Install(P);
   
--testbdd(a);
   
   Put_Line("- Bounds on Approximation Errors: ");
   Start_Time:= Clock;
   Bounds_Approximation_Error.Compute(P);
   End_Time:= Clock;
   Put_Line("  Done."&" Time: "&Float(End_Time-Start_Time)'img);
   
--   Put_Line("- Bounds on Approximation Errors to ZERO: ");
--   Start_Time:= Clock;
--   Bounds_Approximation_Error.Set_Errors_to_Zero(P);
--   End_Time:= Clock;
--   Put_Line("  Done."&" Time: "&Float(End_Time-Start_Time)'img);
   
   
   Put_Line("- Growth bounds: ");
   Start_Time:= Clock;
   Growth_Bound.Compute_Growth_Bound ( P,GB );
   Growth_Bound.Compute_Backward_Growth_Bound_wout_DynamicUncertanties(P,GB_b);
   Growth_Bound.Compute_Backward_Growth_Bound_with_DynamicUncertanties(P,GB_b_W);
   End_Time:= Clock;
   Put_Line("  Done."&" Time: "&Float(End_Time-Start_Time)'img);


   Put_Line("- Abstraction: ");
   Start_Time:= Clock;
   Abstraction_Compute(Abstraction.all,AbstractSpecification,P);
   End_Time:= Clock;
   Put_Line("  Done."&" Time: "&Float(End_Time-Start_Time)'img);

   --Initialize_Abstraction_BDD_Data(Abstraction.all,0,100);

   Put_Line("- Controller Synthesis: ");
   Start_Time:= Clock;
   Solve_Control_Problem(Solution,Abstraction.all,AbstractSpecification);
   End_Time:= Clock;
   Put_Line("  Done."&" Time: "&Float(End_Time-Start_Time)'img);
   
   begin
   Open (File => File,
         Mode => In_File,
         Name => "/proc/self/status");
 

  exception
      when others =>
         Put_Line (Standard_Error,
                   "Can not retrieve used mem info:  /proc/self/status - unavailable");
   
         Status_file:=False;
   end;

If Status_file=True then
  
While not  End_Of_File (File) Loop
 String_w_mem_info:= Ada.Strings.Unbounded.To_Unbounded_String(Get_Line (File));    
If Index(String_w_mem_info, "VmPeak") > 0 then
Put_Line("  Memory, "& Ada.Strings.Unbounded.To_String(String_w_mem_info));
Found_mem_info_in_system_file:=True;
end if;



end loop;
 
If Found_mem_info_in_system_file=False then

Put_Line ("Could not retrieve used mem info from  /proc/self/status: specified keyword 'VmPeak' not found");

end if;


end if;
   Close (File);

   


  Put_Line("- Results: ");
  output_results.write_controller(P,Solution.Controller,Solution.Value_Function,Abstraction.all);
  if output_results.is_control_problem_solved(AbstractSpecification,Solution.Controller,Abstraction.all) then
   Put_Line("  Control problem has been " & ASCII.ESC & "[32m" & "solved." & ASCII.ESC  & "[00m");
   Put_Character_Sequence('-',display_length);
   return 0;
   else 
   Put_Line("  Control problem has not been solved.");
   Put_Character_Sequence('-',display_length);
    return 1;
      end if;

end Main;
