with Interfaces; use Interfaces;
with Interfaces.C; use Interfaces.C;
with Input_values; use Input_values;
with Ada.Unchecked_Deallocation;

with Ada.Text_IO; use Ada.Text_IO;

package body Apriori_Enclosure is

-- -------------------------------------------------------------
-- Every package shall contain the following strings that are       
-- generated by svn automatically (after initial setup by hand)                   
--
   svn_author  : constant String := "$Author: Weber_A $";
   svn_revision: constant String := "$Revision: 2354 $";
   svn_date    : constant String := "$Date: 2021-09-23 09:42:25 +0200 (Do, 23 Sep 2021) $";
-- 
-- To enable the mechanism:                                 
-- 1) Run
-- svn propset svn:keywords "Author Rev Date" <name of file> 
-- 2) Copy-Paste to the file the strings
-- svn_author  : constant String := "$Author: Weber_A $";
-- svn_revision: constant String := "$Revision: 2354 $";
-- svn_date    : constant String := "$Date: 2021-09-23 09:42:25 +0200 (Do, 23 Sep 2021) $";
-- 
-- If a package consists of a body and a specification file
-- then include the strings in the body file. 
-- -------------------------------------------------------------

procedure Compute(enclosure: in out Compact_Hyperinterval_T; 
                         t : in Time_T; 
                        x0 : in Compact_Hyperinterval_T; 
                         u : in Compact_Hyperinterval_T; 
                         w : in Bounds_of_Dynamic_Uncertainties_T)
is
  n : constant Component_Index_T := w'Length;
  m : constant Component_Index_T := u(Lower)'Length;
  type Vector_double_T         is array (1 .. n) of double;
  type Input_Hyperinterval_double_T is array (1 .. 2*m) of double;
  type State_Hyperinterval_double_T is array (1 .. 2*n) of double;
  X0Double  : State_Hyperinterval_double_T;
  UDouble   : Input_Hyperinterval_double_T;
  WDouble   : Vector_double_T;
  EncDouble : State_Hyperinterval_double_T;
  Status    : unsigned;
  -- Below, we define the interface to the C function that implements the algorithm to compute the enclosure
  function apriori_enclosure(enc: out State_Hyperinterval_double_T; 
                              t : in  double; 
                             x0 : in  State_Hyperinterval_double_T; 
                              u : in  Input_Hyperinterval_double_T; 
                              w : in  Vector_double_T ; 
                              n : in  unsigned ; 
                              m : in  unsigned) return unsigned;
      pragma Import (C,apriori_enclosure,"apriori_enclosure");
begin
  -- First load the data to the corresponding arrays.
  for i in Component_Index_T range 1 .. n loop
   WDouble(i)   := double(w(i));
   X0Double(i)  := double(x0(Lower)(i));
   X0Double(i+n):= double(x0(Upper)(i));
   enclosure(Lower)(i)  := -established_types.Float_T'Last;
   enclosure(Upper)(i)   :=  established_types.Float_T'Last;
  end loop;
  -- Second, compute an enclosure
   for i in 1 .. m loop
    UDouble(i)   := double(u(Lower)(i));
    UDouble(i+m) := double(u(Upper)(i));
   end loop;
   status := apriori_enclosure(EncDouble,double(t),X0double,UDouble,WDouble,unsigned(n),unsigned(m));
   if status /= 0 then raise Constraint_Error; end if;
   for i in 1 .. n loop
    -- Form an enclosure
    enclosure(Lower)(i)  := established_types.Float_T'Max(enclosure(Lower)(i),established_types.Float_T(EncDouble(i)));
    enclosure(Upper)(i)  := established_types.Float_T'Min(enclosure(Upper)(i),established_types.Float_T(EncDouble(i+n)));
   end loop;
 end compute;

procedure Compute_backward(enclosure: in out Compact_Hyperinterval_T; 
                         t : in Time_T; 
                        x0 : in Compact_Hyperinterval_T; 
                         u : in Compact_Hyperinterval_T; 
                         w : in Bounds_of_Dynamic_Uncertainties_T)
is
  n : constant Component_Index_T := w'Length;
  m : constant Component_Index_T := u(Lower)'Length;
  type Vector_double_T         is array (1 .. n) of double;
  type Input_Hyperinterval_double_T is array (1 .. 2*m) of double;
  type State_Hyperinterval_double_T is array (1 .. 2*n) of double;
  X0Double  : State_Hyperinterval_double_T;
  UDouble   : Input_Hyperinterval_double_T;
  WDouble   : Vector_double_T;
  EncDouble : State_Hyperinterval_double_T;
  Status    : unsigned;
  -- Below, we define the interface to the C function that implements the algorithm to compute the backward enclosure
  function apriori_enclosure(enc: out State_Hyperinterval_double_T; 
                              t : in  double; 
                             x0 : in  State_Hyperinterval_double_T; 
                              u : in  Input_Hyperinterval_double_T; 
                              w : in  Vector_double_T ; 
                              n : in  unsigned ; 
                              m : in  unsigned) return unsigned;
 
      pragma Import (C,apriori_enclosure,"apriori_enclosure_backward");
begin
  -- First load the data to the corresponding arrays.
  for i in Component_Index_T range 1 .. n loop
   WDouble(i)   := double(w(i));
   X0Double(i)  := double(x0(Lower)(i));
   X0Double(i+n):= double(x0(Upper)(i));
   enclosure(Lower)(i) := -established_types.Float_T'Last;
   enclosure(Upper)(i) :=  established_types.Float_T'Last;
  end loop;
  -- Second, compute an enclosure
   for i in 1 .. m loop
    UDouble(i)   := double(u(Lower)(i));
    UDouble(i+m) := double(u(Upper)(i));
   end loop;
   status := apriori_enclosure(EncDouble,double(t),X0double,UDouble,WDouble,unsigned(n),unsigned(m));
   if status /= 0 then raise Constraint_Error; end if;
   for i in 1 .. n loop
    -- Form an enclosure
    enclosure(Lower)(i)  := established_types.Float_T'Max(enclosure(Lower)(i),established_types.Float_T(EncDouble(i)));
    enclosure(Upper)(i)   := established_types.Float_T'Min(enclosure(Upper)(i),established_types.Float_T(EncDouble(i+n)));
   end loop;
 end compute_backward;
      
   
   
   
procedure compute(P : in out Problem_T) is 
      enclosure : Compact_Hyperinterval_T_Access := new Compact_Hyperinterval_T;
      enclosure_backward_with_DynamicUncertanties : Compact_Hyperinterval_T_Access := new Compact_Hyperinterval_T;
      enclosure_backward_wout_DynamicUncertanties : Compact_Hyperinterval_T_Access := new Compact_Hyperinterval_T;
      x0        : Compact_Hyperinterval_T ;
      u         : Compact_Hyperinterval_T ;
      enc       : Compact_Hyperinterval_T ;
      -- u_val     : Input_T (1 .. P.Input_Space_Dimension);
      w_0       : Bounds_of_Dynamic_Uncertainties_T(1 .. P.State_Space_Dimension):=(others=>0.0);
      InputData : Input_Grid_T    := Input_Values.Install(P);
      function addition_RU(a : in double ; 
                           b : in double) return double;
  pragma Import (C,addition_RU,"addition_RU");
  function subtraction_RD(a : in double ; 
                           b : in double) return double;
  pragma Import (C,subtraction_RD,"subtraction_RD");
  procedure Free is new Ada.Unchecked_Deallocation(Vector_Float_T,Vector_Float_T_Access);
  use InputGrid;
begin
      -- Allocate memory
      for i in End_Point_T loop
         x0(i)  := new Vector_Float_T (P.xmin'Range);
         u(i)   := new Vector_Float_T (P.umin'Range);
         enc(i) := new Vector_Float_T (P.xmin'Range);
         enclosure.all(i) := new Vector_Float_T (P.xmin'Range);
         enclosure_backward_with_DynamicUncertanties.all(i) := new Vector_Float_T (P.xmin'Range);
         enclosure_backward_wout_DynamicUncertanties.all(i) := new Vector_Float_T (P.xmin'Range);      
      end loop;
      -- Initialize and load the data to the corresponding arrays.   
      for i in P.xmin'Range loop
         enclosure(Lower)(i) := -established_types.Float_T'Last;
         enclosure(Upper)(i) :=  established_types.Float_T'Last; 
         
         enclosure_backward_with_DynamicUncertanties(Lower)(i) := -established_types.Float_T'Last;
         enclosure_backward_with_DynamicUncertanties(Upper)(i) :=  established_types.Float_T'Last;        
         enclosure_backward_wout_DynamicUncertanties(Lower)(i) := -established_types.Float_T'Last;
         enclosure_backward_wout_DynamicUncertanties(Upper)(i) :=  established_types.Float_T'Last; 
         
         -- Enlarge the initial set of states by the measurement errors and overapproximate for formal correctness. See ReissigWberRungger17. 
         -- Assumption for formal correctness: the arguments are at most one ULP away from the real values.
         x0(Lower)(i) := subtraction_RD(double(P.xmin(i)), double(P.Bounds_of_Measurement_Errors(i)));
         x0(Upper)(i) :=    addition_RU(double(P.xmax(i)), double(P.Bounds_of_Measurement_Errors(i)));
      end loop;
      -- Define the control range. A enclosure will be computed that is valid for all control inputs.
      -- Assumption for formal correctness: P.umin and P.umax are at most one ULP away from the real values in each component.
      for i in P.umin'Range loop
            u(Lower)(i) := subtraction_RD(P.umin(i), 0.0) ;
            u(Upper)(i) :=    addition_RU(P.umax(i), 0.0) ;
      end loop;
      -- Actual computation of three types of enclosures
      -- ------------------
      -- FORWARD with uncertainties
      Compute(enc,P.Sampling_Time,x0,u,P.Bounds_of_Dynamic_Uncertainties.all);   
      for i in P.xmin'Range loop
            -- Form a uniform enclosure
            enclosure(Lower)(i) := established_types.Float_T'Max(enclosure(Lower)(i),established_types.Float_T(enc(Lower)(i)));
            enclosure(Upper)(i) := established_types.Float_T'Min(enclosure(Upper)(i),established_types.Float_T(enc(Upper)(i)));
      end loop;
      P.Apriori_Enclosure := enclosure; 
      
      -- BACKWARD without uncertainties   
      Compute_backward(enc,P.Sampling_Time,x0,u,w_0);        
      for i in P.xmin'Range loop
        -- Form a uniform enclosure
         enclosure_backward_wout_DynamicUncertanties(Lower)(i) := established_types.Float_T'Max(enclosure_backward_wout_DynamicUncertanties(Lower)(i),established_types.Float_T(enc(Lower)(i)));
         enclosure_backward_wout_DynamicUncertanties(Upper)(i) := established_types.Float_T'Min(enclosure_backward_wout_DynamicUncertanties(Upper)(i),established_types.Float_T(enc(Upper)(i)));
      end loop;
      P.Apriori_Enclosure_Backward_wout_DynamicUncertanties := enclosure_backward_wout_DynamicUncertanties;  
   
      -- BACKWARD with uncertainties      
      Compute_backward(enc,P.Sampling_Time,x0,u,P.Bounds_of_Dynamic_Uncertainties.all);        
      for i in P.xmin'Range loop
        -- Form a uniform enclosure
         enclosure_backward_with_DynamicUncertanties(Lower)(i) := established_types.Float_T'Max(enclosure_backward_with_DynamicUncertanties(Lower)(i),established_types.Float_T(enc(Lower)(i)));
         enclosure_backward_with_DynamicUncertanties(Upper)(i) := established_types.Float_T'Min(enclosure_backward_with_DynamicUncertanties(Upper)(i),established_types.Float_T(enc(Upper)(i)));
      end loop;
      P.Apriori_Enclosure_Backward_with_DynamicUncertanties := enclosure_backward_with_DynamicUncertanties;      
        
      -- OLD implementation:
      --for v in Input_Index_T range 0 .. Input_Index_T(get_number_of_grid_points(InputData)-1) loop 
      --   Get_Input_Value(u_val,v,InputData);
      --   for i in P.umin'Range loop
      --      u(Lower)(i) := u_val(i) ;
      --      u(Upper)(i) := u_val(i) ;
      --   end loop;
         -- Second, compute for each control signal an enclosure
      --   Compute(enc,P.Sampling_Time,x0,u,P.Bounds_of_Dynamic_Uncertainties.all);   
      --   Put_Line("max " & P.umax(1)'Img & " min " & P.umin(1)'Img );
      --   if v = 0 then    
      --      for i in P.xmin'Range loop
            -- Form a uniform enclosure
      --      enclosure(Lower)(i) := established_types.Float_T'Max(enclosure(Lower)(i),established_types.Float_T(enc(Lower)(i)));
      --      enclosure(Upper)(i) := established_types.Float_T'Min(enclosure(Upper)(i),established_types.Float_T(enc(Upper)(i)));
      --      end loop;
      --   else 
      --      for i in P.xmin'Range loop
            -- Form a uniform enclosure
      --      enclosure(Lower)(i) := established_types.Float_T'Min(enclosure(Lower)(i),established_types.Float_T(enc(Lower)(i)));
      --      enclosure(Upper)(i) := established_types.Float_T'Max(enclosure(Upper)(i),established_types.Float_T(enc(Upper)(i)));
           -- Put_Line("aea " & u(Lower)(1)'Img & " " & u(Lower)(2)'Img & "; " & enclosure(Lower)(i)'Img & " " & enclosure(Upper)(i)'Img);
      --      end loop;
      --   end if; 
        
      -- end loop;
      
      --for v in Input_Index_T range 0 .. Input_Index_T(get_number_of_grid_points(InputData)-1) loop 
      --   Get_Input_Value(u_val,v,InputData);
      --   for i in P.umin'Range loop
      --     u(Lower)(i) := u_val(i) ;
      --      u(Upper)(i) := u_val(i) ;
      --   end loop;
         -- Second, compute for each control signal an enclosure
      --   Compute_backward(enc,P.Sampling_Time,x0,u,w_0);        
      --   for i in P.xmin'Range loop
            -- Form a uniform enclosure
      --      enclosure_backward_wout_DynamicUncertanties(Lower)(i) := established_types.Float_T'Max(enclosure_backward_wout_DynamicUncertanties(Lower)(i),established_types.Float_T(enc(Lower)(i)));
      --      enclosure_backward_wout_DynamicUncertanties(Upper)(i) := established_types.Float_T'Min(enclosure_backward_wout_DynamicUncertanties(Upper)(i),established_types.Float_T(enc(Upper)(i)));
      --   end loop;
      -- end loop;
      -- P.Apriori_Enclosure_Backward_wout_DynamicUncertanties := enclosure_backward_wout_DynamicUncertanties;  
      
  
     -- for v in Input_Index_T range 0 .. Input_Index_T(get_number_of_grid_points(InputData)-1) loop 
     --     Get_Input_Value(u_val,v,InputData);
     --    for i in P.umin'Range loop
     --       u(Lower)(i) := u_val(i) ;
     --       u(Upper)(i) := u_val(i) ;
     --    end loop;
         -- Second, compute for each control signal an enclosure
      --   Compute_backward(enc,P.Sampling_Time,x0,u,P.Bounds_of_Dynamic_Uncertainties.all);        
      --   for i in P.xmin'Range loop
            -- Form a uniform enclosure
      --      enclosure_backward_with_DynamicUncertanties(Lower)(i) := established_types.Float_T'Max(enclosure_backward_with_DynamicUncertanties(Lower)(i),established_types.Float_T(enc(Lower)(i)));
      --      enclosure_backward_with_DynamicUncertanties(Upper)(i) := established_types.Float_T'Min(enclosure_backward_with_DynamicUncertanties(Upper)(i),established_types.Float_T(enc(Upper)(i)));
      --   end loop;
      -- end loop;
      -- P.Apriori_Enclosure_Backward_with_DynamicUncertanties := enclosure_backward_with_DynamicUncertanties;      
      --end loop;
            
  for i in End_Point_T loop
  Free(x0(i));
  Free(enc(i));
  end loop;
   end compute;
   
   procedure Expand_State_Domain(P : in out Problem_T) is  
   
      procedure Free_Vector_Float_T_Access is new Ada.Unchecked_Deallocation(Vector_Float_T,Vector_Float_T_Access);   
      procedure Free_Compact_Hyperinterval_T_Access is new Ada.Unchecked_Deallocation(Compact_Hyperinterval_T,Compact_Hyperinterval_T_Access);   
  
   begin
      
    
      
      For i in P.xmin'Range loop
         P.xmin(i):=P.Apriori_Enclosure(lower)(i);
         P.xmax(i):=P.Apriori_Enclosure(Upper)(i);         
      end loop;
      
      for i in End_Point_T loop
         Free_Vector_Float_T_Access(P.Apriori_Enclosure(i));
         Free_Vector_Float_T_Access(P.Apriori_Enclosure_Backward_with_DynamicUncertanties(i));
         Free_Vector_Float_T_Access(P.Apriori_Enclosure_Backward_wout_DynamicUncertanties(i));
      end loop;  
      Free_Compact_Hyperinterval_T_Access(P.Apriori_Enclosure);   
      Free_Compact_Hyperinterval_T_Access(P.Apriori_Enclosure_Backward_with_DynamicUncertanties);  
      Free_Compact_Hyperinterval_T_Access(P.Apriori_Enclosure_Backward_wout_DynamicUncertanties);  
   end Expand_State_Domain;     
   

end apriori_enclosure;
